use crate::{DesktopAppInfo, EntryObject, ListStore, ObjectExt};
use std::collections::HashSet;
use std::path::PathBuf;

// Populate the ListStore with desktop entries
// note that the order in which we lookup data directories
// maters here. We want to get user defined desktop entries first
// because they override their parents in '/user/share/applications'
pub fn get_desktop_entries(store: &ListStore) {
    // We are passing around this hashset to ensure we don"t add duplicate desktop
    // entries. Unfortunately we cannot user the `EntryObject` `Hash` implementation *
    // because it's generated by the `glib::wrapper` macro.
    let mut entry_set = HashSet::new();

    // look for entries in $XDG_DESKTOP_DIR
    if let Some(desktop) = dirs::desktop_dir() {
        desktop_entries_from_path(desktop, store, &mut entry_set);
    }

    // look for entries in $XDG_DATA_HOM
    if let Some(data_dir) = dirs::data_local_dir() {
        desktop_entries_from_path(data_dir, store, &mut entry_set);
    }

    // look for entries in $XDG_DATA_HOM
    if let Some(data_dir) = dirs::data_dir() {
        desktop_entries_from_path(data_dir, store, &mut entry_set);
    }

    // look up root entries
    let path = PathBuf::from("/usr/share/applications");
    desktop_entries_from_path(path, store, &mut entry_set);
}

// Look for all the '.desktop' files in the given path and append them to the `ListStore`
fn desktop_entries_from_path(path: PathBuf, store: &ListStore, entry_set: &mut HashSet<String>) {
    for entry in path.read_dir().expect("Failed to open_dir") {
        let entry = entry.expect("Failed to read desktop entry");

        // Ensure this is a '.desktop' file
        let is_desktop_entry = entry
            .path()
            .extension()
            .map(|ext| ext == "desktop")
            .unwrap_or(false);

        // Load the file as `gio::DesktopAppInfo`
        if is_desktop_entry {
            let widget = DesktopAppInfo::from_filename(entry.path());

            if let Some(entry) = widget {
                let entry = &EntryObject::from(entry);
                let name = entry.property::<String>("name");

                // Ensure we don't have another matching entry already
                if entry_set.insert(name) {
                    store.append(entry);
                }
            }
        }
    }
}
